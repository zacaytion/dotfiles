function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 *
 * 
 */

var _jscodeshift = require('jscodeshift');

var _jscodeshift2 = _interopRequireDefault(_jscodeshift);

var CONFIG = [{
  searchTerms: [_jscodeshift2['default'].ImportDeclaration, { importKind: 'type' }],
  filters: [],
  getNodes: function getNodes(path) {
    return path.node.specifiers.map(function (specifier) {
      return specifier.local;
    });
  }
}, {
  searchTerms: [_jscodeshift2['default'].TypeAlias],
  filters: [],
  getNodes: function getNodes(path) {
    return [path.node.id];
  }
}, {
  searchTerms: [_jscodeshift2['default'].TypeParameterDeclaration],
  filters: [],
  getNodes: function getNodes(path) {
    return path.node.params;
  }
},

// TODO: remove these, they should be covered by TypeParameterDeclaration
// but there is a bug in jscodeshift
{
  searchTerms: [_jscodeshift2['default'].ClassDeclaration],
  filters: [function (path) {
    return path.node.typeParameters && Array.isArray(path.node.typeParameters.params);
  }],
  getNodes: function getNodes(path) {
    return path.node.typeParameters.params;
  }
}];

/**
 * This will get a list of all flow types that are declared within root's AST
 */
function getDeclaredTypes(root, options, filters) {
  // Start with the built in types that are always declared.
  var moduleMap = options.moduleMap;

  var ids = new Set(moduleMap.getBuiltInTypes());
  CONFIG.forEach(function (config) {
    root.find(config.searchTerms[0], config.searchTerms[1]).filter(function (path) {
      return filters ? filters.every(function (filter) {
        return filter(path);
      }) : true;
    }).filter(function (path) {
      return config.filters.every(function (filter) {
        return filter(path);
      });
    }).forEach(function (path) {
      var nodes = config.getNodes(path);
      nodes.forEach(function (node) {
        if (_jscodeshift2['default'].Identifier.check(node)) {
          ids.add(node.name);
        }
      });
    });
  });
  return ids;
}

module.exports = getDeclaredTypes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvZ2V0RGVjbGFyZWRUeXBlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7MkJBYWlCLGFBQWE7Ozs7QUFROUIsSUFBTSxNQUEwQixHQUFHLENBQ2pDO0FBQ0UsYUFBVyxFQUFFLENBQ1gseUJBQUssaUJBQWlCLEVBQ3RCLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBQyxDQUNyQjtBQUNELFNBQU8sRUFBRSxFQUFFO0FBQ1gsVUFBUSxFQUFFLGtCQUFBLElBQUk7V0FBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsVUFBQSxTQUFTO2FBQUksU0FBUyxDQUFDLEtBQUs7S0FBQSxDQUFDO0dBQUE7Q0FDekUsRUFDRDtBQUNFLGFBQVcsRUFBRSxDQUFDLHlCQUFLLFNBQVMsQ0FBQztBQUM3QixTQUFPLEVBQUUsRUFBRTtBQUNYLFVBQVEsRUFBRSxrQkFBQSxJQUFJO1dBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztHQUFBO0NBQ2pDLEVBQ0Q7QUFDRSxhQUFXLEVBQUUsQ0FBQyx5QkFBSyx3QkFBd0IsQ0FBQztBQUM1QyxTQUFPLEVBQUUsRUFBRTtBQUNYLFVBQVEsRUFBRSxrQkFBQSxJQUFJO1dBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNO0dBQUE7Q0FDbkM7Ozs7QUFJRDtBQUNFLGFBQVcsRUFBRSxDQUFDLHlCQUFLLGdCQUFnQixDQUFDO0FBQ3BDLFNBQU8sRUFBRSxDQUNQLFVBQUEsSUFBSTtXQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxJQUN4QixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQztHQUMvQyxDQUNGO0FBQ0QsVUFBUSxFQUFFLGtCQUFBLElBQUk7V0FBSSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNO0dBQUE7Q0FDbEQsQ0FDRixDQUFDOzs7OztBQUtGLFNBQVMsZ0JBQWdCLENBQ3ZCLElBQWdCLEVBQ2hCLE9BQXNCLEVBQ3RCLE9BQTZDLEVBQ2hDOztNQUVOLFNBQVMsR0FBSSxPQUFPLENBQXBCLFNBQVM7O0FBQ2hCLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO0FBQ2pELFFBQU0sQ0FBQyxPQUFPLENBQUMsVUFBQSxNQUFNLEVBQUk7QUFDdkIsUUFBSSxDQUNELElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDbEQsTUFBTSxDQUFDLFVBQUEsSUFBSTthQUFLLE9BQU8sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQUEsTUFBTTtlQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUM7T0FBQSxDQUFDLEdBQUcsSUFBSTtLQUFDLENBQUMsQ0FDeEUsTUFBTSxDQUFDLFVBQUEsSUFBSTthQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQUEsTUFBTTtlQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUM7T0FBQSxDQUFDO0tBQUEsQ0FBQyxDQUM1RCxPQUFPLENBQUMsVUFBQSxJQUFJLEVBQUk7QUFDZixVQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BDLFdBQUssQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJLEVBQUk7QUFDcEIsWUFBSSx5QkFBSyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQy9CLGFBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BCO09BQ0YsQ0FBQyxDQUFDO0tBQ0osQ0FBQyxDQUFDO0dBQ04sQ0FBQyxDQUFDO0FBQ0gsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLGdCQUFnQixDQUFDIiwiZmlsZSI6ImdldERlY2xhcmVkVHlwZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7Q29sbGVjdGlvbiwgTm9kZSwgTm9kZVBhdGh9IGZyb20gJy4uL3R5cGVzL2FzdCc7XG5pbXBvcnQgdHlwZSB7U291cmNlT3B0aW9uc30gZnJvbSAnLi4vb3B0aW9ucy9Tb3VyY2VPcHRpb25zJztcblxuaW1wb3J0IGpzY3MgZnJvbSAnanNjb2Rlc2hpZnQnO1xuXG50eXBlIENvbmZpZ0VudHJ5ID0ge1xuICBzZWFyY2hUZXJtczogW2FueSwgP09iamVjdF0sXG4gIGZpbHRlcnM6IEFycmF5PChwYXRoOiBOb2RlUGF0aCkgPT4gYm9vbGVhbj4sXG4gIGdldE5vZGVzOiAocGF0aDogTm9kZVBhdGgpID0+IEFycmF5PE5vZGU+LFxufTtcblxuY29uc3QgQ09ORklHOiBBcnJheTxDb25maWdFbnRyeT4gPSBbXG4gIHtcbiAgICBzZWFyY2hUZXJtczogW1xuICAgICAganNjcy5JbXBvcnREZWNsYXJhdGlvbixcbiAgICAgIHtpbXBvcnRLaW5kOiAndHlwZSd9LFxuICAgIF0sXG4gICAgZmlsdGVyczogW10sXG4gICAgZ2V0Tm9kZXM6IHBhdGggPT4gcGF0aC5ub2RlLnNwZWNpZmllcnMubWFwKHNwZWNpZmllciA9PiBzcGVjaWZpZXIubG9jYWwpLFxuICB9LFxuICB7XG4gICAgc2VhcmNoVGVybXM6IFtqc2NzLlR5cGVBbGlhc10sXG4gICAgZmlsdGVyczogW10sXG4gICAgZ2V0Tm9kZXM6IHBhdGggPT4gW3BhdGgubm9kZS5pZF0sXG4gIH0sXG4gIHtcbiAgICBzZWFyY2hUZXJtczogW2pzY3MuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXSxcbiAgICBmaWx0ZXJzOiBbXSxcbiAgICBnZXROb2RlczogcGF0aCA9PiBwYXRoLm5vZGUucGFyYW1zLFxuICB9LFxuXG4gIC8vIFRPRE86IHJlbW92ZSB0aGVzZSwgdGhleSBzaG91bGQgYmUgY292ZXJlZCBieSBUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cbiAgLy8gYnV0IHRoZXJlIGlzIGEgYnVnIGluIGpzY29kZXNoaWZ0XG4gIHtcbiAgICBzZWFyY2hUZXJtczogW2pzY3MuQ2xhc3NEZWNsYXJhdGlvbl0sXG4gICAgZmlsdGVyczogW1xuICAgICAgcGF0aCA9PiAoXG4gICAgICAgIHBhdGgubm9kZS50eXBlUGFyYW1ldGVycyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHBhdGgubm9kZS50eXBlUGFyYW1ldGVycy5wYXJhbXMpXG4gICAgICApLFxuICAgIF0sXG4gICAgZ2V0Tm9kZXM6IHBhdGggPT4gcGF0aC5ub2RlLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcyxcbiAgfSxcbl07XG5cbi8qKlxuICogVGhpcyB3aWxsIGdldCBhIGxpc3Qgb2YgYWxsIGZsb3cgdHlwZXMgdGhhdCBhcmUgZGVjbGFyZWQgd2l0aGluIHJvb3QncyBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0RGVjbGFyZWRUeXBlcyhcbiAgcm9vdDogQ29sbGVjdGlvbixcbiAgb3B0aW9uczogU291cmNlT3B0aW9ucyxcbiAgZmlsdGVycz86ID9BcnJheTwocGF0aDogTm9kZVBhdGgpID0+IGJvb2xlYW4+LFxuKTogU2V0PHN0cmluZz4ge1xuICAvLyBTdGFydCB3aXRoIHRoZSBidWlsdCBpbiB0eXBlcyB0aGF0IGFyZSBhbHdheXMgZGVjbGFyZWQuXG4gIGNvbnN0IHttb2R1bGVNYXB9ID0gb3B0aW9ucztcbiAgY29uc3QgaWRzID0gbmV3IFNldChtb2R1bGVNYXAuZ2V0QnVpbHRJblR5cGVzKCkpO1xuICBDT05GSUcuZm9yRWFjaChjb25maWcgPT4ge1xuICAgIHJvb3RcbiAgICAgIC5maW5kKGNvbmZpZy5zZWFyY2hUZXJtc1swXSwgY29uZmlnLnNlYXJjaFRlcm1zWzFdKVxuICAgICAgLmZpbHRlcihwYXRoID0+IChmaWx0ZXJzID8gZmlsdGVycy5ldmVyeShmaWx0ZXIgPT4gZmlsdGVyKHBhdGgpKSA6IHRydWUpKVxuICAgICAgLmZpbHRlcihwYXRoID0+IGNvbmZpZy5maWx0ZXJzLmV2ZXJ5KGZpbHRlciA9PiBmaWx0ZXIocGF0aCkpKVxuICAgICAgLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gY29uZmlnLmdldE5vZGVzKHBhdGgpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChqc2NzLklkZW50aWZpZXIuY2hlY2sobm9kZSkpIHtcbiAgICAgICAgICAgIGlkcy5hZGQobm9kZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH0pO1xuICByZXR1cm4gaWRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldERlY2xhcmVkVHlwZXM7XG4iXX0=
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 *
 * 
 */

var _jscodeshift = require('jscodeshift');

var _jscodeshift2 = _interopRequireDefault(_jscodeshift);

/**
 * This will get a list of all types that are not from a declaration.
 *
 * NOTE: this can get types that are declared, if you want access to
 * types that are used but undeclared see getUndeclaredTypes
 */
function getNonDeclarationTypes(root) {
  var ids = new Set();

  // Pull out the logic to handle a generic type annotation, we have to iterate
  // down the qualified types to handle things like: `<Immutable.List<Foo>>`
  function handleGenericType(node) {
    if (_jscodeshift2['default'].Identifier.check(node.id)) {
      ids.add(node.id.name);
    }
    if (_jscodeshift2['default'].QualifiedTypeIdentifier.check(node.id)) {
      var currPos = node.id;
      while (currPos && !_jscodeshift2['default'].Identifier.check(currPos)) {
        currPos = currPos.qualification;
      }
      if (_jscodeshift2['default'].Identifier.check(currPos)) {
        ids.add(currPos.name);
      }
    }
  }

  // Ideally this would be the only find in here, but it's not because of a
  // jscodeshift bug, so we have to manually search for a specific kind of
  // GenericTypeAnnotations on class super types
  root.find(_jscodeshift2['default'].GenericTypeAnnotation).forEach(function (path) {
    return handleGenericType(path.node);
  });

  // TODO: Delete this after https://github.com/facebook/jscodeshift/issues/34
  root.find(_jscodeshift2['default'].ClassDeclaration).filter(function (path) {
    return path.node.superTypeParameters && Array.isArray(path.node.superTypeParameters.params);
  }).forEach(function (path) {
    (0, _jscodeshift2['default'])(path.node.superTypeParameters).find(_jscodeshift2['default'].GenericTypeAnnotation).forEach(function (subPath) {
      return handleGenericType(subPath.node);
    });
  });

  return ids;
}

module.exports = getNonDeclarationTypes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvZ2V0Tm9uRGVjbGFyYXRpb25UeXBlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7MkJBWWlCLGFBQWE7Ozs7Ozs7Ozs7QUFROUIsU0FBUyxzQkFBc0IsQ0FBQyxJQUFnQixFQUFlO0FBQzdELE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7Ozs7QUFJdEIsV0FBUyxpQkFBaUIsQ0FBQyxJQUFVLEVBQVE7QUFDM0MsUUFBSSx5QkFBSyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNsQyxTQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDdkI7QUFDRCxRQUFJLHlCQUFLLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDL0MsVUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUN0QixhQUFPLE9BQU8sSUFBSSxDQUFDLHlCQUFLLFVBQVUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7QUFDakQsZUFBTyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUM7T0FDakM7QUFDRCxVQUFJLHlCQUFLLFVBQVUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7QUFDbEMsV0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDdkI7S0FDRjtHQUNGOzs7OztBQUtELE1BQUksQ0FDRCxJQUFJLENBQUMseUJBQUsscUJBQXFCLENBQUMsQ0FDaEMsT0FBTyxDQUFDLFVBQUEsSUFBSTtXQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7R0FBQSxDQUFDLENBQUM7OztBQUdqRCxNQUFJLENBQ0QsSUFBSSxDQUFDLHlCQUFLLGdCQUFnQixDQUFDLENBQzNCLE1BQU0sQ0FBQyxVQUFBLElBQUk7V0FDVixJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixJQUM3QixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDO0dBQ3BELENBQUMsQ0FDRCxPQUFPLENBQUMsVUFBQSxJQUFJLEVBQUk7QUFDZixrQ0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQ2hDLElBQUksQ0FBQyx5QkFBSyxxQkFBcUIsQ0FBQyxDQUNoQyxPQUFPLENBQUMsVUFBQSxPQUFPO2FBQUksaUJBQWlCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztLQUFBLENBQUMsQ0FBQztHQUN4RCxDQUFDLENBQUM7O0FBRUwsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLHNCQUFzQixDQUFDIiwiZmlsZSI6ImdldE5vbkRlY2xhcmF0aW9uVHlwZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7Q29sbGVjdGlvbiwgTm9kZX0gZnJvbSAnLi4vdHlwZXMvYXN0JztcblxuaW1wb3J0IGpzY3MgZnJvbSAnanNjb2Rlc2hpZnQnO1xuXG4vKipcbiAqIFRoaXMgd2lsbCBnZXQgYSBsaXN0IG9mIGFsbCB0eXBlcyB0aGF0IGFyZSBub3QgZnJvbSBhIGRlY2xhcmF0aW9uLlxuICpcbiAqIE5PVEU6IHRoaXMgY2FuIGdldCB0eXBlcyB0aGF0IGFyZSBkZWNsYXJlZCwgaWYgeW91IHdhbnQgYWNjZXNzIHRvXG4gKiB0eXBlcyB0aGF0IGFyZSB1c2VkIGJ1dCB1bmRlY2xhcmVkIHNlZSBnZXRVbmRlY2xhcmVkVHlwZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9uRGVjbGFyYXRpb25UeXBlcyhyb290OiBDb2xsZWN0aW9uKTogU2V0PHN0cmluZz4ge1xuICBjb25zdCBpZHMgPSBuZXcgU2V0KCk7XG5cbiAgLy8gUHVsbCBvdXQgdGhlIGxvZ2ljIHRvIGhhbmRsZSBhIGdlbmVyaWMgdHlwZSBhbm5vdGF0aW9uLCB3ZSBoYXZlIHRvIGl0ZXJhdGVcbiAgLy8gZG93biB0aGUgcXVhbGlmaWVkIHR5cGVzIHRvIGhhbmRsZSB0aGluZ3MgbGlrZTogYDxJbW11dGFibGUuTGlzdDxGb28+PmBcbiAgZnVuY3Rpb24gaGFuZGxlR2VuZXJpY1R5cGUobm9kZTogTm9kZSk6IHZvaWQge1xuICAgIGlmIChqc2NzLklkZW50aWZpZXIuY2hlY2sobm9kZS5pZCkpIHtcbiAgICAgIGlkcy5hZGQobm9kZS5pZC5uYW1lKTtcbiAgICB9XG4gICAgaWYgKGpzY3MuUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIuY2hlY2sobm9kZS5pZCkpIHtcbiAgICAgIGxldCBjdXJyUG9zID0gbm9kZS5pZDtcbiAgICAgIHdoaWxlIChjdXJyUG9zICYmICFqc2NzLklkZW50aWZpZXIuY2hlY2soY3VyclBvcykpIHtcbiAgICAgICAgY3VyclBvcyA9IGN1cnJQb3MucXVhbGlmaWNhdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChqc2NzLklkZW50aWZpZXIuY2hlY2soY3VyclBvcykpIHtcbiAgICAgICAgaWRzLmFkZChjdXJyUG9zLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElkZWFsbHkgdGhpcyB3b3VsZCBiZSB0aGUgb25seSBmaW5kIGluIGhlcmUsIGJ1dCBpdCdzIG5vdCBiZWNhdXNlIG9mIGFcbiAgLy8ganNjb2Rlc2hpZnQgYnVnLCBzbyB3ZSBoYXZlIHRvIG1hbnVhbGx5IHNlYXJjaCBmb3IgYSBzcGVjaWZpYyBraW5kIG9mXG4gIC8vIEdlbmVyaWNUeXBlQW5ub3RhdGlvbnMgb24gY2xhc3Mgc3VwZXIgdHlwZXNcbiAgcm9vdFxuICAgIC5maW5kKGpzY3MuR2VuZXJpY1R5cGVBbm5vdGF0aW9uKVxuICAgIC5mb3JFYWNoKHBhdGggPT4gaGFuZGxlR2VuZXJpY1R5cGUocGF0aC5ub2RlKSk7XG5cbiAgLy8gVE9ETzogRGVsZXRlIHRoaXMgYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2pzY29kZXNoaWZ0L2lzc3Vlcy8zNFxuICByb290XG4gICAgLmZpbmQoanNjcy5DbGFzc0RlY2xhcmF0aW9uKVxuICAgIC5maWx0ZXIocGF0aCA9PiAoXG4gICAgICBwYXRoLm5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycyAmJlxuICAgICAgQXJyYXkuaXNBcnJheShwYXRoLm5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycy5wYXJhbXMpXG4gICAgKSlcbiAgICAuZm9yRWFjaChwYXRoID0+IHtcbiAgICAgIGpzY3MocGF0aC5ub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMpXG4gICAgICAgIC5maW5kKGpzY3MuR2VuZXJpY1R5cGVBbm5vdGF0aW9uKVxuICAgICAgICAuZm9yRWFjaChzdWJQYXRoID0+IGhhbmRsZUdlbmVyaWNUeXBlKHN1YlBhdGgubm9kZSkpO1xuICAgIH0pO1xuXG4gIHJldHVybiBpZHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm9uRGVjbGFyYXRpb25UeXBlcztcbiJdfQ==